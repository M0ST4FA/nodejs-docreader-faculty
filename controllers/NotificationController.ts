import catchAsync from '../utils/catchAsync';
import { Request, Response, NextFunction } from 'express';
import AppError from '../utils/AppError';
import LinkModel from '../models/Link';
import McqQuizModel from '../models/McqQuiz';
import fcmService from '../utils/FCMService';
import DeviceModel from '../models/Device';
import notificationBodySchema from '../schema/notification.schema';
import TopicModel from '../models/Topic';
import NotificationService from '../utils/NotificationService';
import WrittenQuizModel from '../models/WrittenQuiz';

export default class NotificationController {
  private static extractTopicName(req: Request): string {
    const name = req.params.name;

    if (name === undefined)
      throw new AppError(
        'Invalid topic name: topic name must be a string.',
        400,
      );

    return name;
  }

  private static extractYearIDFromUrl(req: Request): number {
    if (req.params.name === undefined)
      throw new AppError(
        'Topic name must be specified when querying for notifiable resources under a given topic.',
        400,
      );

    const id = Number.parseInt(req.params.name);

    if (Number.isNaN(id))
      throw new AppError('Invalid year ID: year ID must be an integer.', 400);

    return id;
  }

  private static async extractCurrentUserDevices(
    req: Request,
  ): Promise<Partial<DeviceModel[]>> {
    const devices = (await DeviceModel.findMany(
      {
        userId: req.user.id,
      },
      { fields: 'token' },
    )) as DeviceModel[];

    if (devices.length === 0)
      throw new AppError(
        'The logged in user account does not have any device associated with them.',
        400,
      );

    return devices;
  }

  private static async validateNotificationBody(body: any) {
    const validatedNotificationBody = notificationBodySchema.safeParse(body);

    if (validatedNotificationBody.error)
      throw new AppError(
        `Invalid notification body: [ ${validatedNotificationBody.error.issues.map(
          issue => issue.message,
        )} ]`,
        400,
      );

    const notification = validatedNotificationBody.data;

    return notification;
  }

  static getNotifiableResources = catchAsync(async function (
    req: Request,
    res: Response,
    next: NextFunction,
  ) {
    const yearId = NotificationController.extractYearIDFromUrl(req);

    const [links, mcqQuizzes, writtenQuizzes] = await Promise.all([
      LinkModel.findNotifiable(yearId),
      McqQuizModel.findNotifiable(yearId),
      WrittenQuizModel.findNotifiable(yearId),
    ]);
    res.status(200).json({
      status: 'success',
      data: { links, mcqQuizzes, writtenQuizzes },
    });
  });

  static setGlobalTopic = catchAsync(async function (
    req: Request,
    res: Response,
    next: NextFunction,
  ) {
    req.params.name = 'global_announcements';

    next();
  });

  static broadcastToTopic = catchAsync(async function (
    req: Request,
    res: Response,
    next: NextFunction,
  ) {
    // Extract topic name
    const topicName = NotificationController.extractTopicName(req);

    // Check whether the topic already exists (an exception is thrown if it doesn't)
    const topic = await TopicModel.findOneByName(topicName, {});

    // Extract and validate notification body
    const notification = await NotificationController.validateNotificationBody(
      req.body,
    );

    const messageId = await NotificationService.broadcastToTopic(
      notification,
      topic.name,
    );

    res.status(200).json({
      status: 'success',
      data: {
        messageId,
      },
    });
  });

  static test = catchAsync(async function (
    req: Request,
    res: Response,
    next: NextFunction,
  ) {
    const devices = (await NotificationController.extractCurrentUserDevices(
      req,
    )) as Partial<DeviceModel>[];
    const notification = await NotificationController.validateNotificationBody(
      req.body,
    );

    if (notification.type === 'autogenerated')
      throw new AppError('Test notification cannot be autogenerated.', 400);

    if (notification.body === undefined)
      throw new AppError('Test notification must have a body.', 400);

    const result = await fcmService.multicastNotification(
      notification.body,
      devices.map(device => device.token!),
    );

    res.status(207).json({
      status: 'partial',
      totalCount: result.successCount + result.failureCount,
      successCount: result.successCount,
      failureCount: result.failureCount,
      data: {
        successfulTokens: result.successfulTokens,
        failedTokens: result.failedTokens,
      },
    });
  });
}
